#   多态分析
##    何为多态：
      通过虚函数机制，基类有一个或者多个虚函数的时候，编译期间，系统为基类创建一个虚函数表，虚函数表中记录了虚函数的地址，当子类重写虚函数时，虚函数指针指向新的函数地址，运行期间确定函数方法。
##    具体见实例
     (传送门)[]

##   重载,重写，重定义
    1.重载 可有可无virtual
    2.重写（覆盖）针对virtual而言，派生类进行覆盖基类方法
    3.重定义（隐藏）派生类函数，屏蔽了与基类同名的函数定义
      （1）派生类与基类同名，但是参数不同，不管有无virtual 基类函数都被隐蔽。
      （2）基类函数与派生类函数相同，但是基类没有virtual关键字，此时基类的函数被
    隐藏。

##  深拷贝浅拷贝
    1.在未定义拷贝构造函数的情况下，系统会调用默认构造函数-浅拷贝，其能完成成员的一一拷贝复制，当数据成员中，没有指针的情况下复制是可行的。
    2.在需要复制的成员中 ，含有指针的时候，若采用简单的浅拷贝，则两个指针指向同一个地址，对象块析构的时候，会调用两次析构函数，导致指针悬挂现象，此时必须采用深拷贝。
    3.深拷贝浅拷贝的区别就在于，深拷贝会在堆内存中申请空间来存储数据，从而解决了指针悬挂的问题，简而言之，当需要拷贝的对象中含有指针的时候，必须使用深拷贝。

    (案例传送门)[]

##  智能指针	

   智能指针个人理解，为了能够保证使用堆上的内存能够及时释放，讲基础类型的指针封装为类对象指针，类的析构函数编入delete函数释放指针对应的内存空间。
 C++11之前的智能指针为auto_ptr,析构函数释放指着指向的内存，但是其存在致命缺陷：
 auto_ptr 进行赋值操作时候，被赋值的取得其所有权，去赋值的丢失其所有权变为悬空指针，容易造成crash（变成空指针，无法再使用）；
不够方便：没有移动语义（后面讲）。
###  unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括：

1、拥有它指向的对象

2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作

3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象

unique_ptr 可以实现如下功能：

1、为动态申请的内存提供异常安全

2、讲动态申请的内存所有权传递给某函数

3、从某个函数返回动态申请内存的所有权

4、在容器中保存指针
   
   
