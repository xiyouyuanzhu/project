##  一、什么是defunct进程(僵尸进程)?   
    在 Linux 系统中,一个进程结束了,但是他的父进程没有等待(调用wait / waitpid)他,  
    那么他将变成一个僵尸进程。当用ps命令观察进程的执行状态时,看到这些进程的状态栏为defunct。
    僵尸进程是一个早已死亡的进程,但在进程表(processs table)中仍占了一个位置(slot)。  
    但是如果该进程的父进程已经先结束了,那么该进程就不会变成僵尸进程。因为每个进程结束的时候,  
    系统都会扫描当前系统中所运行的所有进程,看看有没有哪个进程是刚刚结束的这个进程的子进程,  
    如果是的话,就由Init进程来接管他,成为他的父进程,从而保证每个进程都会有一个父进程。
    而Init进程会自动wait其子进程,因此被Init接管的所有进程都不会变成僵尸进程。     

##  二、 Linux下进程的运作方式  
    每个 Linux进程在进程表里都有一个进入点(entry),  
    核心进程执行该进程时使用到的一切信息都存储在进入点。  
    当用 ps 命令察看系统中的进程信息时,看到的就是进程表中的相关数据。  
    当以fork()系统调用建立一个新的进程后,核心进程就会在进程表中给这个新进程分配一个进入点,  
    然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。  
    子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束。  
    那么会不会因为父进程太忙来不及 wait 子进程,或者说不知道子进程什么时候结束,  
    而丢失子进程结束时的状态信息呢?不会。因为 Linux提供了一种机制可以保证,  
    只要父进程想知道子进程结束时的状态信息,就可以得到。这种机制就是:当子进程走完了自己的生命周期后,  
    它会执行exit()系统调用,内核释放该进程所有的资源,包括打开的文件,占用的内存等。  
    但是仍然为其保留一定的信息(包括进程号the process ID,退出码exit code,  
    退出状态the terminationstatus of the process,运行时间the amount of CPU time taken by the   
    process等),  
    这些数据会一直保留到系统将它传递给它的父进程为止,直到父进程通过wait / waitpid来取时才释放。  
    也就是说,当一个进程死亡时,它并不是完全的消失了。  
    进程终止,它不再运行,但是还有一些残留的数据等待父进程收回。  
    当父进程 fork() 一个子进程后,它必须用 wait() (或者 waitpid())等待子进程退出。  
    正是这个 wait() 动作来让子进程的残留数据消失。  
##  解决方案：
    编写脚本进行人机交互，调用正则表达式来提取僵尸进程的父进程Pid ,通过杀死父进程的pid 从而使僵尸进程本身成为孤儿进程。
    
    
##  具体实现方案见代码：
       
  **(案例传送门)[https://github.com/xiyouyuanzhu/project/blob/master/KillDefunct/KillDefunct.py]**

